<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Face Ticketing â€” Manual Save Only</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bg:#071022;--panel:#0b1320;--accent:#10b981;--text:#e6f7f1}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,Arial;background:var(--bg);color:var(--text);display:flex;align-items:center;justify-content:center;min-height:100vh}
    .app{display:flex;gap:18px;width:100%;max-width:1280px;padding:18px}
    .camera{position:relative;width:820px}
    video{width:820px;height:615px;background:#000;border-radius:10px;object-fit:cover;transform:scaleX(-1)}
    canvas{position:absolute;left:0;top:0;width:820px;height:615px;pointer-events:none}
    .panel{width:360px;background:var(--panel);padding:16px;border-radius:12px}
    .btn{width:100%;padding:12px;border-radius:10px;border:none;cursor:pointer;font-weight:700;margin-top:8px}
    .btn-verify{background:#3b82f6;color:#fff}
    .btn-refresh{background:#f59e0b;color:#012}
    .btn-save{background:var(--accent);color:#012}
    .status{margin-top:12px;color:#bde;font-size:14px;min-height:46px}
    .small{font-size:13px;color:#9db;margin-top:8px}
    #datetime{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.45);padding:8px 10px;border-radius:8px;z-index:20}
    #message{position:absolute;right:12px;top:12px;z-index:20;text-align:right}
    #message .msg{background:rgba(0,0,0,0.6);padding:6px 10px;border-radius:8px;color:#fff}
    .controls-below { display:flex; gap:12px; justify-content:center; margin-top:12px; }
    .controls-below button { min-width:170px; }
  </style>
</head>
<body>
  <div class="app">
    <div>
      <div class="camera">
        <div id="datetime">--</div>
        <div id="message"><div class="msg">Initializing...</div></div>
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay" width="820" height="615"></canvas>
      </div>

      <!-- Buttons directly under the video (as requested) -->
      <div class="controls-below">
        <button id="manualSaveBtn" class="btn btn-save">Save Unknowns (current view)</button>
        <button id="manualVerifyBtn" class="btn btn-verify">Quick Verify</button>
      </div>
    </div>

    <div class="panel">
      <h3 style="margin:0 0 8px 0">Face Ticket System (Online-only)</h3>

      <button id="refreshBtn" class="btn btn-refresh">Reload Known Faces</button>

      <div class="row">
        <label class="small" style="display:block">Threshold: <b><span id="threshVal">0.55</span></b>
          <input id="threshold" type="range" min="0.40" max="0.70" step="0.01" value="0.55" style="width:100%" />
        </label>
      </div>

      <div class="row" style="margin-top:8px">
        <label class="small" style="display:block">Process every N: <b><span id="procVal">2</span></b>
          <input id="proc" type="range" min="1" max="4" step="1" value="2" style="width:100%" />
        </label>
      </div>

      <div class="small" style="margin-top:6px">
        Use the <b>Save Unknowns</b> button to store unknown faces as tickets under <code>/faceTickets/{ticketId}</code>.
      </div>

      <div class="status" id="status">Loading models...</div>
    </div>
  </div>

  <!-- face-api bundle (includes TF) -->
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getDatabase, ref, get, set, child } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";

    // ---------- CONFIG ----------
    const MODEL_URL = 'https://raw.githubusercontent.com/myselfrakib/Face/main/models'; // change if needed
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyDsn16p7w8b-x8pEA_WTO5F2oUk4MHwcUc",
      authDomain: "wavetravel-3c4c4.firebaseapp.com",
      databaseURL: "https://wavetravel-3c4c4-default-rtdb.firebaseio.com",
      projectId: "wavetravel-3c4c4",
      storageBucket: "wavetravel-3c4c4.firebasestorage.app",
      messagingSenderId: "298226098137",
      appId: "1:298226098137:web:720953b80e3e61c8bc43c8"
    };
    const TICKETS_PATH = 'faceTickets';
    const RESIZE_SCALE = 0.25;

    // ---------- UI ----------
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const messageEl = document.getElementById('message');
    const datetimeEl = document.getElementById('datetime');

    const manualSaveBtn = document.getElementById('manualSaveBtn');
    const manualVerifyBtn = document.getElementById('manualVerifyBtn');
    const refreshBtn = document.getElementById('refreshBtn');

    const thresholdInput = document.getElementById('threshold');
    const procInput = document.getElementById('proc');
    const threshVal = document.getElementById('threshVal');
    const procVal = document.getElementById('procVal');

    let MATCH_THRESHOLD = parseFloat(thresholdInput.value);
    let PROCESS_EVERY_N = parseInt(procInput.value,10) || 2;
    threshVal.innerText = MATCH_THRESHOLD.toFixed(2);
    procVal.innerText = PROCESS_EVERY_N;
    thresholdInput.oninput = ()=> { MATCH_THRESHOLD = parseFloat(thresholdInput.value); threshVal.innerText = MATCH_THRESHOLD.toFixed(2); };
    procInput.oninput = ()=> { PROCESS_EVERY_N = parseInt(procInput.value,10); procVal.innerText = PROCESS_EVERY_N; };

    function setStatus(t){ statusEl.innerText = t; messageEl.innerHTML = `<div class="msg">${t}</div>`; }
    function setMessage(t, ms=2000){ messageEl.innerHTML = `<div class="msg">${t}</div>`; setTimeout(()=> messageEl.innerHTML='', ms); }
    function updateDateTime(){ datetimeEl.innerText = new Date().toLocaleString(); }
    setInterval(updateDateTime, 1000); updateDateTime();

    // ---------- state ----------
    let db;
    let knownTickets = []; // {id, encoding: Float32Array, meta}
    let modelsLoaded = false;
    let frameIdx = 0;
    let latestDetections = [];

    // ---------- firebase init ----------
    function initFirebase(){
      const app = initializeApp(FIREBASE_CONFIG);
      db = getDatabase(app);
      setStatus("Firebase initialized");
    }

    // ---------- load models ----------
    async function loadModels(){
      setStatus("Setting TF backend and loading models...");
      try {
        if (faceapi?.tf?.setBackend) {
          try { await faceapi.tf.setBackend('webgl'); await faceapi.tf.ready(); }
          catch(e){ await faceapi.tf.setBackend('cpu'); await faceapi.tf.ready(); }
        }
      } catch(e){ console.warn("backend switch error", e); }
      await Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
        faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
        faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
        faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL),
        faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)
      ]);
      modelsLoaded = true;
      setStatus("Models loaded");
    }

    // ---------- camera ----------
    async function startCamera(){
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width:1280, height:720 } });
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        setStatus("Camera started");
      } catch(e){
        console.error(e);
        setStatus("Camera access error");
      }
    }

    // ---------- db helpers ----------
    async function loadKnownTicketsFromFirebase(){
      try {
        setStatus("Loading known tickets from Firebase...");
        const snap = await get(ref(db, TICKETS_PATH));
        const data = snap.exists() ? snap.val() : {};
        const loaded = [];
        for (const [k,v] of Object.entries(data || {})){
          const enc = v.encoding || v.descriptor || null;
          if (Array.isArray(enc) && enc.length >= 128) loaded.push({ id:k, encoding: new Float32Array(enc), meta:v });
        }
        knownTickets = loaded;
        setStatus(`Loaded ${knownTickets.length} tickets`);
      } catch(e){
        console.error("loadKnownTicketsFromFirebase", e);
        setStatus("Failed to load tickets (check console)");
      }
    }

    async function allocateTicketIdOnline(){
      const now = new Date();
      const prefix = String(now.getMonth()+1).padStart(2,'0') + String(now.getFullYear());
      try {
        const snap = await get(ref(db, TICKETS_PATH));
        const data = snap.exists() ? snap.val() : {};
        const keys = Object.keys(data || {});
        const samePrefix = keys.filter(k => k.startsWith(prefix)).map(k => parseInt(k,10)).filter(n => !isNaN(n));
        if (!samePrefix.length) return prefix + '101';
        return String(Math.max(...samePrefix) + 1);
      } catch(e){
        console.warn('allocateTicketIdOnline error', e);
        return prefix + String(Math.floor(Date.now() / 1000));
      }
    }

    async function saveTicketOnline(ticketId, encoding, meta={}){
      const payload = Object.assign({ encoding: Array.from(encoding), timestamp: new Date().toISOString() }, meta);
      await set(child(ref(db), `${TICKETS_PATH}/${ticketId}`), payload);
      knownTickets.push({ id: ticketId, encoding: new Float32Array(encoding), meta: payload });
      setStatus(`Saved ${ticketId}`);
    }

    // ---------- math helpers ----------
    function euclidean(a,b){ let s=0; for(let i=0;i<a.length;i++){ const d=a[i]-b[i]; s+=d*d;} return Math.sqrt(s); }
    function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }

    function findBestMatchLocal(descriptor){
      if (!knownTickets.length) return { found:false, bestId:null, distance:Infinity, confidence:0.0 };
      let best = { id:null, dist: Infinity };
      for (const t of knownTickets){
        const d = euclidean(descriptor, t.encoding);
        if (d < best.dist) best = { id: t.id, dist: d };
      }
      const found = best.dist <= MATCH_THRESHOLD;
      const conf = clamp(1 - (best.dist / Math.max(MATCH_THRESHOLD, 1e-6)), 0, 1);
      return { found, bestId: best.id, distance: best.dist, confidence: parseFloat(conf.toFixed(2)) };
    }

    // ---------- detection ----------
    async function detectAllSmall(){
      if (!modelsLoaded) return [];
      const off = document.createElement('canvas');
      off.width = Math.max(1, Math.floor(video.videoWidth * RESIZE_SCALE));
      off.height = Math.max(1, Math.floor(video.videoHeight * RESIZE_SCALE));
      const offCtx = off.getContext('2d');
      offCtx.drawImage(video, 0, 0, off.width, off.height);

      try {
        const detections = await faceapi
          .detectAllFaces(off, new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.45 }))
          .withFaceLandmarks()
          .withFaceDescriptors()
          .withFaceExpressions()
          .withAgeAndGender();

        return detections.map(d => {
          const b = d.detection.box;
          return {
            box: {
              x: Math.round(b.x / RESIZE_SCALE),
              y: Math.round(b.y / RESIZE_SCALE),
              width: Math.round(b.width / RESIZE_SCALE),
              height: Math.round(b.height / RESIZE_SCALE)
            },
            descriptor: d.descriptor,
            age: d.age,
            gender: d.gender,
            expressions: d.expressions,
            landmarks: d.landmarks
          };
        });
      } catch(e){
        console.warn("detectAllSmall error", e);
        return [];
      }
    }

    function makeKeyFromDescriptor(enc){
      const arr = Array.from(enc).slice(0,8).map(x => Math.round(x*10000)/10000);
      return arr.join(',');
    }

    // ---------- main loop (NO AUTOSAVE) ----------
    async function mainLoop(){
      frameIdx++;
      if (frameIdx % PROCESS_EVERY_N === 0 && modelsLoaded){
        latestDetections = await detectAllSmall();
      }
      drawOverlay();
      requestAnimationFrame(mainLoop);
    }

    // ---------- drawing overlay ----------
    function drawOverlay(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.setTransform(-1, 0, 0, 1, canvas.width, 0); // mirror to match video

      for (const det of latestDetections){
        const b = det.box;
        const m = findBestMatchLocal(det.descriptor);
        const label = m.found ? m.bestId : 'Unknown';

        if (m.found){
          ctx.strokeStyle = 'lime';
          ctx.lineWidth = Math.max(2, Math.round(Math.min(6, b.width*0.02)));
          ctx.strokeRect(b.x, b.y, b.width, b.height);
        } else {
          const cx = b.x + Math.round(b.width/2), cy = b.y + Math.round(b.height/2), r = Math.round(Math.max(b.width,b.height)/2);
          ctx.strokeStyle = 'rgba(255,80,80,0.95)';
          ctx.lineWidth = Math.max(2, Math.round(Math.min(6, b.width*0.02)));
          ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
        }

        const info = [];
        if (m.found) info.push(`conf ${Math.round(m.confidence*100)}%`);
        if (Number.isFinite(det.age)) info.push(`age ${Math.round(det.age)}`);
        if (det.gender) info.push(det.gender);
        const expr = Object.entries(det.expressions || {}).sort((a,b)=>b[1]-a[1])[0];
        if (expr && expr[0]) info.push(expr[0]);

        const text = [label, info.join(' â€¢ ')].filter(Boolean).join(' â€” ');
        ctx.font = '16px Arial';
        const padX = 8, padY = 22;
        const w = Math.min(360, ctx.measureText(text).width + 2*padX);
        ctx.fillStyle = m.found ? 'rgba(0,128,0,0.85)' : 'rgba(200,40,40,0.9)';
        ctx.fillRect(b.x, b.y + b.height - padY, w, padY);
        ctx.fillStyle = '#fff';
        ctx.fillText(text, b.x + 6, b.y + b.height - 6);
      }
      ctx.restore();
      updateDateTime();
    }

    // ---------- manual actions ----------
    manualVerifyBtn.addEventListener('click', async () => {
      setStatus("Manual verify: scanning...");
      const dets = await detectAllSmall();
      if (!dets.length){ setStatus("No face detected"); return; }
      for (const d of dets){
        const m = findBestMatchLocal(d.descriptor);
        const label = m.found ? `Ticket: ${m.bestId} (conf ${Math.round(m.confidence*100)}%)` : 'Unknown';
        setMessage(label, 3000);
      }
    });

    refreshBtn.addEventListener('click', async () => {
      await loadKnownTicketsFromFirebase();
      setMessage('Known faces reloaded', 1500);
    });

    // Manual Save button: saves ALL unknown detections in the current view
    manualSaveBtn.addEventListener('click', async () => {
      if (!modelsLoaded) { setMessage('Models not ready'); return; }
      const dets = await detectAllSmall();
      if (!dets.length){ setMessage('No faces in view'); return; }

      const unknowns = dets.filter(d => !findBestMatchLocal(d.descriptor).found);
      if (!unknowns.length){ setMessage('No unknown faces found'); return; }

      setStatus(`Saving ${unknowns.length} unknown(s) to Firebase...`);
      let saved = 0;
      for (const d of unknowns){
        try{
          const ticketId = await allocateTicketIdOnline();
          await saveTicketOnline(ticketId, d.descriptor, {
            note: 'manual-save',
            age: Math.round(d.age||0),
            gender: d.gender || 'unknown',
            topExpression: Object.entries(d.expressions||{}).sort((a,b)=>b[1]-a[1])[0]?.[0] || 'neutral'
          });
          saved++;
        } catch(e){
          console.error('Manual save failed:', e);
        }
      }
      setMessage(`Saved ${saved}/${unknowns.length} unknown(s)`, 3000);
      await loadKnownTicketsFromFirebase(); // refresh in-memory list
    });

    // ---------- init ----------
    async function init(){
      try {
        initFirebase();
        await loadModels();
        await startCamera();
        await loadKnownTicketsFromFirebase();
        setStatus("Ready. Press 'Save Unknowns' to store unknown faces.");
        mainLoop();
        setInterval(loadKnownTicketsFromFirebase, 60_000);
      } catch(e){
        console.error("Init error:", e);
        setStatus("Initialization failed - see console");
      }
    }
    init();

    // debug
    window.__faceTickets = { knownTickets, latestDetections };
  </script>
</body>
</html>