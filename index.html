<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Multi-person Face Ticket Scanner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0b1220; --panel:#071122; --accent:#10b981; --bad:#ff3b30; --text:#dff7ef; }
    body { margin:0; font-family:Inter, Arial, sans-serif; background:var(--bg); color:var(--text); display:flex; flex-direction:column; align-items:center; min-height:100vh; }
    header { padding:14px; text-align:center; }
    #wrap { display:flex; gap:18px; padding:12px; align-items:flex-start; }
    #camera { position:relative; width:800px; }
    video { width:800px; height:600px; background:#000; border-radius:10px; transform: scaleX(-1); /* mirror for user */ }
    canvas { position:absolute; left:0; top:0; width:800px; height:600px; pointer-events:none; }
    #panel { width:360px; background:var(--panel); padding:14px; border-radius:10px; box-shadow: 0 8px 30px rgba(0,0,0,0.6); }
    .btn { width:100%; padding:12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; margin-top:8px; }
    .btn-primary { background:var(--accent); color:#012; }
    .btn-verify { background:#3b82f6; color:#fff; }
    #status { margin-top:10px; color:#bde; font-size:14px; min-height:24px; }
    .small { font-size:13px; color:#9db; margin-top:8px; }
    #datetime { position:absolute; left:12px; top:12px; background:rgba(0,0,0,0.45); padding:8px 10px; border-radius:8px; font-weight:700; }
    #msgs { position:absolute; right:12px; top:12px; text-align:right; }
    #msgs .msg { background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:8px; margin-bottom:6px; }
    #qrs { margin-top:12px; display:flex; flex-direction:column; gap:8px; align-items:center; }
    .qr-item { background:#07161a;padding:8px;border-radius:8px;width:100%; text-align:center; color:#9fe; }
    code { color:#9fe; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <h2>Multi-person Face Ticket Scanner</h2>
    <div style="font-size:13px;color:#9bb">Detects multiple people, matches tickets, generate tickets for unknowns</div>
  </header>

  <div id="wrap">
    <div id="camera">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="overlay" width="800" height="600"></canvas>
      <div id="datetime"></div>
      <div id="msgs"></div>
    </div>

    <div id="panel">
      <button id="generateBtn" class="btn btn-primary">Generate Tickets for Unknowns</button>
      <button id="verifyBtn" class="btn btn-verify">Verify All Now</button>

      <div id="status">Loading models...</div>

      <div class="small">Threshold: <span id="threshVal">0.55</span></div>
      <input id="threshold" type="range" min="0.40" max="0.70" step="0.01" value="0.55" style="width:100%" />

      <div class="small">Samples per unknown (for averaging): <span id="sampleVal">5</span></div>
      <input id="samples" type="range" min="3" max="9" step="2" value="5" style="width:100%" />

      <div class="small" style="margin-top:10px">QRs / last saved tickets:</div>
      <div id="qrs"></div>

      <div class="small" style="margin-top:10px">Storage: <code>/tickets/{ticketId}</code> (descriptor array + timestamp)</div>
    </div>
  </div>

  <!-- face-api UMD global -->
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

  <!-- Firebase modular + logic -->
  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
  import { getDatabase, ref, get, set, child } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";

  // ----- FIREBASE CONFIG (use your project) -----
  const firebaseConfig = {
    apiKey: "AIzaSyDsn16p7w8b-x8pEA_WTO5F2oUk4MHwcUc",
    authDomain: "wavetravel-3c4c4.firebaseapp.com",
    databaseURL: "https://wavetravel-3c4c4-default-rtdb.firebaseio.com",
    projectId: "wavetravel-3c4c4",
    storageBucket: "wavetravel-3c4c4.firebasestorage.app",
    messagingSenderId: "298226098137",
    appId: "1:298226098137:web:720953b80e3e61c8bc43c8"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const ticketsPath = 'tickets';

  // ----- UI elements -----
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const msgsEl = document.getElementById('msgs');
  const datetimeEl = document.getElementById('datetime');
  const generateBtn = document.getElementById('generateBtn');
  const verifyBtn = document.getElementById('verifyBtn');
  const qrsEl = document.getElementById('qrs');

  const thresholdInput = document.getElementById('threshold');
  const samplesInput = document.getElementById('samples');
  const threshVal = document.getElementById('threshVal');
  const sampleVal = document.getElementById('sampleVal');

  // ----- settings/state -----
  let MATCH_THRESHOLD = parseFloat(thresholdInput.value); thresholdInput.oninput = ()=>{ MATCH_THRESHOLD = parseFloat(thresholdInput.value); threshVal.innerText = MATCH_THRESHOLD.toFixed(2); };
  let SAMPLES = parseInt(samplesInput.value,10); sampleVal.innerText = SAMPLES; samplesInput.oninput = ()=>{ SAMPLES = parseInt(samplesInput.value,10); sampleVal.innerText = SAMPLES; };

  const RESIZE_SCALE = 0.25;
  const PROCESS_EVERY_N = 2;

  let knownTickets = []; // [{id, encoding:Float32Array, meta}]
  let latestDetections = []; // per-frame detections with boxes and descriptors
  let modelsLoaded = false;

  // ----- helpers -----
  function showMsg(text, timeout=2200) {
    const div = document.createElement('div'); div.className='msg'; div.innerText = text; msgsEl.prepend(div);
    setTimeout(()=> div.remove(), timeout);
  }
  function updateDateTime(){ datetimeEl.innerText = new Date().toLocaleString(); }
  setInterval(updateDateTime,1000); updateDateTime();

  function euclidean(a,b){
    let s=0; for (let i=0;i<a.length;i++){ const d=a[i]-b[i]; s+=d*d; } return Math.sqrt(s);
  }

  // ----- load known tickets from Firebase -----
  async function loadKnownTickets(){
    try{
      statusEl.innerText = 'Loading tickets from Firebase...';
      const snap = await get(child(ref(db), ticketsPath));
      const data = snap.exists() ? snap.val() : {};
      const loaded = [];
      for (const [k,v] of Object.entries(data)){
        const arr = v.encoding || v.descriptor || v.descriptorArray || v.descriptorArrayFloat || null;
        if (Array.isArray(arr) && arr.length >= 128) {
          loaded.push({ id: k, encoding: new Float32Array(arr), meta: v });
        }
      }
      knownTickets = loaded;
      statusEl.innerText = `Loaded ${knownTickets.length} ticket(s)`;
    } catch(e){
      console.error(e);
      statusEl.innerText = 'Failed to load tickets';
    }
  }

  // ----- model load & camera start -----
  async function init(){
    try{
      statusEl.innerText = 'Loading face-api models...';
      await Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri('./models'),
        faceapi.nets.faceLandmark68Net.loadFromUri('./models'),
        faceapi.nets.faceRecognitionNet.loadFromUri('./models')
      ]);
      modelsLoaded = true;
      statusEl.innerText = 'Models loaded. Starting camera...';
      await startCamera();
      await loadKnownTickets();
      setInterval(loadKnownTickets, 30000); // refresh periodically
      runLoop();
    } catch(e){
      console.error(e);
      statusEl.innerText = 'Model or camera error (check ./models and camera)';
    }
  }

  async function startCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ width:1280, height:720 }});
      video.srcObject = stream;
      await video.play();
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      statusEl.innerText = 'Camera started';
    } catch(e){
      console.error("Camera error", e);
      statusEl.innerText = 'Cannot access camera';
    }
  }

  // ----- main detection loop (handles multiple faces) -----
  let frameIdx = 0;
  async function runLoop(){
    const off = document.createElement('canvas');
    off.width = Math.max(1, Math.floor(video.videoWidth * RESIZE_SCALE));
    off.height = Math.max(1, Math.floor(video.videoHeight * RESIZE_SCALE));
    const offCtx = off.getContext('2d');

    async function step(){
      frameIdx++;
      offCtx.drawImage(video, 0, 0, off.width, off.height);

      if (frameIdx % PROCESS_EVERY_N === 0 && modelsLoaded) {
        try {
          const detections = await faceapi.detectAllFaces(off, new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.45 }))
            .withFaceLandmarks()
            .withFaceDescriptors();

          // convert detection boxes to full-size coords and store descriptor
          latestDetections = detections.map(d => {
            const b = d.detection.box;
            return {
              box: { x: Math.round(b.x / RESIZE_SCALE), y: Math.round(b.y / RESIZE_SCALE),
                     width: Math.round(b.width / RESIZE_SCALE), height: Math.round(b.height / RESIZE_SCALE) },
              descriptor: d.descriptor
            };
          });
        } catch(e) {
          console.error("detectAllFaces error", e);
        }
      }

      // draw overlay (clear first)
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // For each detection, find best match and draw
      for (const det of latestDetections){
        // find best ticket
        let best = { id:null, dist: Infinity };
        for (const t of knownTickets) {
          const d = euclidean(det.descriptor, t.encoding);
          if (d < best.dist) { best.dist = d; best.id = t.id; }
        }

        // Compute mirrored X so shapes align with mirrored video (video is CSS-mirrored). We do not mirror canvas; compute mirroredX.
        const x = det.box.x, y = det.box.y, w = det.box.width, h = det.box.height;
        const mirroredX = canvas.width - x - w;

        if (best.dist <= MATCH_THRESHOLD) {
          // green rect + label
          ctx.strokeStyle = 'lime';
          ctx.lineWidth = Math.max(2, Math.round(Math.min(6, w*0.02)));
          ctx.strokeRect(mirroredX, y, w, h);

          // label background (draw rectangle)
          const label = best.id || 'ticket';
          const textW = Math.min(260, ctx.measureText(label).width + 12);
          ctx.fillStyle = 'rgba(0,128,0,0.85)';
          ctx.fillRect(mirroredX, y + h - 26, textW, 26);

          // draw label text (unmirrored, normal orientation)
          ctx.fillStyle = '#fff';
          ctx.font = '16px Arial';
          ctx.fillText(label, mirroredX + 6, y + h - 6);
        } else {
          // unknown -> red circle
          const cx = mirroredX + Math.round(w/2);
          const cy = y + Math.round(h/2);
          const r = Math.round(Math.max(w,h)/2);
          ctx.strokeStyle = 'rgba(255,60,60,0.95)';
          ctx.lineWidth = Math.max(2, Math.round(Math.min(6, w*0.02)));
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI*2);
          ctx.stroke();

          // label
          ctx.fillStyle = 'rgba(200,40,40,0.9)';
          ctx.fillRect(mirroredX, y + h - 26, 110, 26);
          ctx.fillStyle = '#fff';
          ctx.font = '14px Arial';
          ctx.fillText('Unknown', mirroredX + 6, y + h - 6);
        }
      }

      requestAnimationFrame(step);
    }

    requestAnimationFrame(step);
  }

  // ----- helper: allocate next ticket ids for a batch (prefix = MMYYYY) -----
  async function allocateTicketIds(prefix, count) {
    // read existing once
    try {
      const snap = await get(child(ref(db), ticketsPath));
      const data = snap.exists() ? snap.val() : {};
      const existingKeys = Object.keys(data || {}).filter(k => k.startsWith(prefix));
      // parse numbers, choose max
      const numeric = existingKeys.map(k => parseInt(k,10)).filter(x => !isNaN(x));
      let next = numeric.length ? Math.max(...numeric) + 1 : parseInt(prefix + '101',10);
      const out = [];
      for (let i=0;i<count;i++){
        out.push(String(next));
        next++;
      }
      return out;
    } catch(e){
      console.error("allocateTicketIds error", e);
      // fallback simple sequence
      const base = parseInt(prefix + '101',10);
      return Array.from({length: count}, (_,i) => String(base + i));
    }
  }

  // ----- helper: average descriptors for one face by re-sampling around its position -----
  // We'll take quick re-detections and match nearest descriptor to the original face box.
  async function sampleAverageForBoxes(boxes, samplesPerBox=5, delayMs=180) {
    // boxes: array of {x,y,width,height} in full coords (unmirrored x)
    const results = [];
    for (const box of boxes) results.push([]);

    for (let s=0; s<samplesPerBox; s++){
      // small detection on full video (we'll find matches by box overlap)
      const off = document.createElement('canvas');
      off.width = Math.max(1, Math.floor(video.videoWidth * RESIZE_SCALE));
      off.height = Math.max(1, Math.floor(video.videoHeight * RESIZE_SCALE));
      const offCtx = off.getContext('2d');
      offCtx.drawImage(video, 0, 0, off.width, off.height);
      const dets = await faceapi.detectAllFaces(off, new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.45 })).withFaceLandmarks().withFaceDescriptors();
      // scale det boxes to full coords
      const fullDets = dets.map(d => {
        const b = d.detection.box;
        return { box: { x: Math.round(b.x / RESIZE_SCALE), y: Math.round(b.y / RESIZE_SCALE), width: Math.round(b.width / RESIZE_SCALE), height: Math.round(b.height / RESIZE_SCALE) }, descriptor: d.descriptor };
      });

      // for each target box, find the detection with largest IoU or nearest center
      for (let i=0;i<boxes.length;i++){
        const t = boxes[i];
        let best = {det:null, score:-1};
        for (const fd of fullDets){
          // compute center distance
          const cx = fd.box.x + fd.box.width/2, cy = fd.box.y + fd.box.height/2;
          const tcx = t.x + t.width/2, tcy = t.y + t.height/2;
          const dist = Math.hypot(cx - tcx, cy - tcy);
          const score = 1 / (1 + dist);
          if (score > best.score) best = {det:fd, score};
        }
        if (best.det) results[i].push(best.det.descriptor);
      }
      await new Promise(r => setTimeout(r, delayMs));
    }

    // average each list
    function avg(list){
      if (!list || list.length===0) return null;
      const L = list[0].length;
      const out = new Float32Array(L);
      for (const a of list) for (let i=0;i<L;i++) out[i]+=a[i];
      for (let i=0;i<L;i++) out[i]/=list.length;
      return out;
    }
    return results.map(lst => avg(lst));
  }

  // ----- Generate tickets for all currently UNKNOWN faces -----
  generateBtn.addEventListener('click', async () => {
    if (!modelsLoaded) { showMsg('Models still loading'); return; }
    if (!latestDetections || latestDetections.length===0) { showMsg('No faces visible'); return; }

    // find currently unknown faces (those whose best match > threshold)
    const unknownBoxes = [];
    const unknownDetDescriptors = []; // keep descriptors too
    for (const det of latestDetections) {
      // find best distance
      let best = {dist: Infinity};
      for (const t of knownTickets) {
        const d = euclidean(det.descriptor, t.encoding);
        if (d < best.dist) best = { dist: d, id: t.id };
      }
      if (best.dist > MATCH_THRESHOLD) {
        // we need original (unmirrored) box. latestDetections' box.x is unmirrored full coord (that's what detection produced)
        unknownBoxes.push(det.box);
        unknownDetDescriptors.push(det.descriptor);
      }
    }

    if (unknownBoxes.length === 0) { showMsg('No unknown faces to create tickets for'); return; }

    statusEl.innerText = `Capturing ${SAMPLES} samples for ${unknownBoxes.length} unknown face(s)...`;
    showMsg(`Preparing ${unknownBoxes.length} ticket(s)`);

    // sample/average descriptors for each unknown
    const averaged = await sampleAverageForBoxes(unknownBoxes, SAMPLES);
    // filter out any that failed
    const validPairs = averaged.map((a, i) => ({avg: a, box: unknownBoxes[i]})).filter(x => x.avg !== null);
    if (validPairs.length === 0) { showMsg('Capture failed - try again'); statusEl.innerText='Capture failed'; return; }

    // allocate ticket ids for this batch
    const now = new Date();
    const prefix = String(now.getMonth()+1).padStart(2,'0') + String(now.getFullYear());
    const ids = await allocateTicketIds(prefix, validPairs.length);

    // save each to Firebase
    const savedTickets = [];
    for (let i=0;i<validPairs.length;i++){
      const id = ids[i];
      const desc = Array.from(validPairs[i].avg);
      const data = { descriptor: desc, timestamp: new Date().toISOString() };
      try {
        await set(child(ref(db), `${ticketsPath}/${id}`), data);
        savedTickets.push(id);
      } catch(e){
        console.error("Save ticket error", e);
      }
    }

    if (savedTickets.length) {
      showMsg(`Saved ${savedTickets.length} ticket(s)`, 'rgba(20,120,80,0.95)');
      statusEl.innerText = `Saved ${savedTickets.length} ticket(s): ${savedTickets.join(', ')}`;
      // show QR thumbnails
      qrsEl.innerHTML = '';
      for (const tid of savedTickets) {
        const div = document.createElement('div'); div.className='qr-item';
        const url = `${location.origin}/ticket.html?ticket=${encodeURIComponent(tid)}`;
        div.innerHTML = `<div style="font-weight:700">${tid}</div>
          <img alt="qr" src="https://chart.googleapis.com/chart?cht=qr&chs=150x150&chl=${encodeURIComponent(url)}" style="margin-top:8px;border-radius:6px" />`;
        qrsEl.prepend(div);
      }
      // reload known tickets to include newly saved ones
      await loadKnownTickets();
    } else {
      showMsg('No tickets saved (error)', 'rgba(255,80,80,0.95)');
    }
  });

  // ----- quick verify (single-shot for all faces) -----
  verifyBtn.addEventListener('click', async () => {
    if (!modelsLoaded) { showMsg('Models loading'); return; }
    if (!latestDetections || latestDetections.length===0) { showMsg('No faces visible'); return; }
    let found = 0;
    let bestInfo = [];
    for (const det of latestDetections) {
      let best = {id:null, dist: Infinity};
      for (const t of knownTickets) {
        const d = euclidean(det.descriptor, t.encoding);
        if (d < best.dist) best = { id: t.id, dist: d };
      }
      if (best.dist <= MATCH_THRESHOLD) { found++; bestInfo.push(`${best.id} (d=${best.dist.toFixed(3)})`); }
      else bestInfo.push(`Unknown (best d=${best.dist.toFixed(3)})`);
    }
    showMsg(`Verified: ${found}/${latestDetections.length}`);
    statusEl.innerText = bestInfo.join(' | ');
  });

  // ----- allocateTicketIds used earlier -----
  async function allocateTicketIds(prefix, count) {
    try {
      const snap = await get(child(ref(db), ticketsPath));
      const data = snap.exists() ? snap.val() : {};
      const existing = Object.keys(data || {}).filter(k => k.startsWith(prefix));
      const nums = existing.map(k => parseInt(k,10)).filter(x => !isNaN(x));
      let next = nums.length ? Math.max(...nums) + 1 : parseInt(prefix + '101',10);
      const out = [];
      for (let i=0;i<count;i++){ out.push(String(next)); next++; }
      return out;
    } catch(e){
      console.error(e); const base = parseInt(prefix+'101',10); return Array.from({length:count}, (_,i)=>String(base+i));
    }
  }

  // ----- init -----
  init();

  // expose some internals for debugging
  window.__faceTickets = { loadKnownTickets, knownTickets, latestDetections };

  </script>
</body>
</html>
