<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Face Recognition with Firebase</title>
  <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
    import { getDatabase, ref, get, set } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-database.js";

    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyDsn16p7w8b-x8pEA_WTO5F2oUk4MHwcUc",
      authDomain: "wavetravel-3c4c4.firebaseapp.com",
      databaseURL: "https://wavetravel-3c4c4-default-rtdb.firebaseio.com",
      projectId: "wavetravel-3c4c4",
      storageBucket: "wavetravel-3c4c4.appspot.com",
      messagingSenderId: "298226098137",
      appId: "1:298226098137:web:720953b80e3e61c8bc43c8"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Constants and variables
    const MODEL_URL = 'https://raw.githubusercontent.com/myselfrakib/Face/main/models';
    const video = document.getElementById('videoInput');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    let knownDescriptors = [];
    let knownLabels = [];
    let nextId = 100;

    let faceMatcher = null;
    const maxDescriptorDistance = 0.6;

    let detectionActive = false;
    let processingUnknown = false;
    let unknownDescriptor = null;
    let unknownBox = null;
    let redBoxTimeout = null;

    // Helpers to convert descriptors
    function descriptorToArray(descriptor) {
      return Array.from(descriptor);
    }
    function arrayToDescriptor(arr) {
      return new Float32Array(arr);
    }

    // Load known faces from Firebase
    async function loadKnownFaces() {
      const facesRef = ref(db, 'faces');
      const snapshot = await get(facesRef);
      knownDescriptors = [];
      knownLabels = [];
      nextId = 100;

      if (snapshot.exists()) {
        const data = snapshot.val();
        for (const [id, face] of Object.entries(data)) {
          if (face.encoding && face.name) {
            knownDescriptors.push(arrayToDescriptor(face.encoding));
            knownLabels.push(face.name);
            const numericId = parseInt(id, 10);
            if (!isNaN(numericId) && numericId >= nextId) nextId = numericId + 1;
          }
        }
      }
      console.log(`Loaded ${knownLabels.length} faces. Next ID: ${nextId}`);

      // Setup faceMatcher
      const labeledDescriptors = knownLabels.map((label, i) =>
        new faceapi.LabeledFaceDescriptors(label, [knownDescriptors[i]])
      );
      faceMatcher = new faceapi.FaceMatcher(labeledDescriptors, maxDescriptorDistance);
    }

    // Save unknown face after form submission
    async function saveNewFace(name, age, height) {
      if (!unknownDescriptor) {
        alert("No face data to save!");
        return;
      }
      const id = nextId++;
      const faceRef = ref(db, `faces/${id}`);
      await set(faceRef, {
        name,
        age,
        height,
        encoding: descriptorToArray(unknownDescriptor),
        timestamp: new Date().toISOString()
      });
      // Add to known faces arrays & update matcher
      knownDescriptors.push(unknownDescriptor);
      knownLabels.push(name);
      faceMatcher = new faceapi.FaceMatcher(
        knownLabels.map((label, i) => new faceapi.LabeledFaceDescriptors(label, [knownDescriptors[i]])),
        maxDescriptorDistance
      );

      console.log(`Saved new face: ${name} with ID: ${id}`);

      // Reset unknown data
      unknownDescriptor = null;
      unknownBox = null;
      processingUnknown = false;

      // Restart detection
      detectionActive = true;
      recognizeLoop();
    }

    // Flip box horizontally for mirrored video
    function flipBoxHorizontally(box, canvasWidth) {
      return {
        x: canvasWidth - box.x - box.width,
        y: box.y,
        width: box.width,
        height: box.height
      };
    }

    // Draw green box with label (fix text flip)
    function drawGreenBox(box, text) {
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.strokeRect(box.x, box.y, box.width, box.height);

      // Save and reset transform to draw text unflipped
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);  // reset any transforms

      ctx.fillStyle = 'lime';
      ctx.font = '18px Arial';

      // Position text relative to box, but remember canvas is mirrored visually, so adjust X
      // We want text at box.x from left (normal coords), so:
      ctx.fillText(text, box.x, box.y > 20 ? box.y - 8 : box.y + 20);

      ctx.restore();
    }

    // Draw red box with label (fix text flip)
    function drawRedBox(box) {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 3;
      ctx.strokeRect(box.x, box.y, box.width, box.height);

      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.fillStyle = 'red';
      ctx.font = '18px Arial';
      ctx.fillText('Unknown', box.x, box.y > 20 ? box.y - 8 : box.y + 20);

      ctx.restore();
    }

    // Main recognition loop
    async function recognizeLoop() {
      if (!detectionActive) return;

      const centerX = video.videoWidth / 2;
      const centerY = video.videoHeight / 2;
      const regionSize = Math.min(video.videoWidth, video.videoHeight) * 0.6;

      const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
        .withFaceLandmarks()
        .withFaceDescriptors();

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (detections.length === 0) {
        requestAnimationFrame(recognizeLoop);
        return;
      }

      let detection = detections[0];
      let box = detection.detection.box;
      box = flipBoxHorizontally(box, canvas.width);

      const regionLeft = centerX - regionSize / 2;
      const regionRight = centerX + regionSize / 2;
      const regionTop = centerY - regionSize / 2;
      const regionBottom = centerY + regionSize / 2;

      const boxCenterX = box.x + box.width / 2;
      const boxCenterY = box.y + box.height / 2;

      if (
        boxCenterX < regionLeft || boxCenterX > regionRight ||
        boxCenterY < regionTop || boxCenterY > regionBottom
      ) {
        requestAnimationFrame(recognizeLoop);
        return;
      }

      const descriptor = detection.descriptor;
      const bestMatch = faceMatcher.findBestMatch(descriptor);

      if (bestMatch.label !== "unknown") {
        drawGreenBox(box, bestMatch.label);
        processingUnknown = false;
        unknownDescriptor = null;
        unknownBox = null;
        if (redBoxTimeout) {
          clearTimeout(redBoxTimeout);
          redBoxTimeout = null;
        }
        requestAnimationFrame(recognizeLoop);
      } else {
        if (!processingUnknown) {
          processingUnknown = true;
          unknownDescriptor = descriptor;
          unknownBox = box;
          drawRedBox(box);
          redBoxTimeout = setTimeout(() => {
            detectionActive = false;
            showForm();
          }, 3000);
        } else {
          drawRedBox(unknownBox);
        }
      }
    }

    // Show form to input info
    function showForm() {
      const formDiv = document.getElementById('infoFormDiv');
      formDiv.style.display = 'block';
      document.getElementById('nameInput').focus();
    }

    // Hide form and restart detection
    function hideForm() {
      const formDiv = document.getElementById('infoFormDiv');
      formDiv.style.display = 'none';
    }

    // Start webcam
    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        detectionActive = true;
        processingUnknown = false;
        unknownDescriptor = null;
        unknownBox = null;
        recognizeLoop();
      } catch (e) {
        alert("Error accessing camera: " + e.message);
      }
    }

    // Stop webcam
    function stopCamera() {
      detectionActive = false;
      const stream = video.srcObject;
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      video.srcObject = null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      processingUnknown = false;
      unknownDescriptor = null;
      unknownBox = null;
    }

    // On form submit save data & resume detection
    async function onSave() {
      const name = document.getElementById('nameInput').value.trim();
      const age = document.getElementById('ageInput').value.trim();
      const height = document.getElementById('heightInput').value.trim();

      if (!name) {
        alert("Please enter a name.");
        return;
      }

      await saveNewFace(name, age, height);
      hideForm();
    }

    // Load models and known faces then enable start button
    async function init() {
      await Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
        faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
        faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
      ]);
      await loadKnownFaces();
      document.getElementById('startBtn').disabled = false;
    }

    window.onload = () => {
      init();

      document.getElementById('startBtn').onclick = startCamera;
      document.getElementById('stopBtn').onclick = stopCamera;
      document.getElementById('saveBtn').onclick = onSave;
      document.getElementById('cancelBtn').onclick = () => {
        hideForm();
        detectionActive = true;
        recognizeLoop();
      };
    };
  </script>

  <style>
    body {
      margin: 0; padding: 0;
      background: #222;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    #videoContainer {
      position: relative;
      width: 640px;
      margin: 20px auto;
    }
    #videoInput {
      width: 640px;
      height: 480px;
      object-fit: cover;
      transform: scaleX(-1); /* mirror */
      border-radius: 8px;
    }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 640px;
      height: 480px;
      pointer-events: none;
      transform: scaleX(-1);
      border-radius: 8px;
    }
    #controls {
      margin: 10px;
    }
    button {
      margin: 0 8px;
      padding: 8px 20px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background-color: #4caf50;
      color: white;
      transition: background-color 0.3s ease;
    }
    button:disabled {
      background-color: #777;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #45a049;
    }
    #infoFormDiv {
      background: #333;
      border-radius: 8px;
      width: 320px;
      padding: 20px;
      margin: 20px auto;
      display: none;
    }
    #infoFormDiv input {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      border-radius: 4px;
      border: none;
      font-size: 16px;
    }
    #infoFormDiv label {
      display: block;
      margin-top: 10px;
      text-align: left;
      font-weight: bold;
    }
    #infoFormDiv button {
      width: 48%;
      margin: 10px 1%;
      background-color: #2196F3;
    }
    #infoFormDiv button.cancel {
      background-color: #f44336;
    }
  </style>
</head>
<body>
  <h2>Face Recognition with Firebase</h2>

  <div id="videoContainer">
    <video id="videoInput" autoplay muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="controls">
    <button id="startBtn" disabled>Start Camera</button>
    <button id="stopBtn">Stop Camera</button>
  </div>

  <div id="infoFormDiv">
    <h3>New Face Detected</h3>
    <label for="nameInput">Name:</label>
    <input type="text" id="nameInput" placeholder="Enter name" />
    <label for="ageInput">Age:</label>
    <input type="number" id="ageInput" placeholder="Enter age" />
    <label for="heightInput">Height (cm):</label>
    <input type="number" id="heightInput" placeholder="Enter height in cm" />
    <div>
      <button id="saveBtn">Save</button>
      <button id="cancelBtn" class="cancel">Cancel</button>
    </div>
  </div>
</body>
</html>
