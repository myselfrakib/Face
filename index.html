<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Multi-person Face Ticketing (manual save)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#071022; --panel:#0b1320; --accent:#10b981; --bad:#ff4d4f; --text:#e6f7f1; }
    body { margin:0; font-family:Inter, Arial; background:var(--bg); color:var(--text); display:flex; flex-direction:column; align-items:center; min-height:100vh; }
    header { padding:12px; text-align:center; }
    #wrap { display:flex; gap:18px; padding:12px; align-items:flex-start; width:100%; max-width:1200px; }
    #camera { position:relative; width:800px; }
    video { width:800px; height:600px; background:#000; border-radius:10px; transform: scaleX(-1); /* mirrored for user */ }
    canvas { position:absolute; left:0; top:0; width:800px; height:600px; pointer-events:none; }
    #panel { width:360px; background:var(--panel); padding:14px; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
    .btn { width:100%; padding:12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; margin-top:8px; }
    .btn-primary { background:var(--accent); color:#012; }
    .btn-verify { background:#3b82f6; color:#fff; }
    #status { margin-top:10px; color:#bde; font-size:14px; min-height:24px; }
    .small { font-size:13px; color:#9db; margin-top:8px; }
    #datetime { position:absolute; left:12px; top:12px; background:rgba(0,0,0,0.45); padding:8px 10px; border-radius:8px; font-weight:700; }
    #msgs { position:absolute; right:12px; top:12px; text-align:right; }
    #msgs .msg { background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:8px; margin-bottom:6px; }
    code { color:#9fe; font-size:12px; }
    #qrs { margin-top:12px; display:flex; flex-direction:column; gap:8px; align-items:center; }
    .qr-item { background:#07161a;padding:8px;border-radius:8px;width:100%; text-align:center; color:#9fe; }
  </style>
</head>
<body>
  <header>
    <h2>Multi-person Face Ticketing â€” Manual Save</h2>
    <div style="font-size:13px;color:#9bb">Detects multiple faces, lets you generate tickets for unknowns and stores descriptor under <code>/faceTickets/{ticketId}</code></div>
  </header>

  <div id="wrap">
    <div id="camera">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="overlay" width="800" height="600"></canvas>
      <div id="datetime"></div>
      <div id="msgs"></div>
    </div>

    <div id="panel">
      <button id="generateBtn" class="btn btn-primary">Generate Tickets for Unknowns</button>
      <button id="verifyBtn" class="btn btn-verify">Quick Verify</button>

      <div id="status">Loading models...</div>

      <div class="small">Threshold: <span id="threshVal">0.55</span></div>
      <input id="threshold" type="range" min="0.40" max="0.70" step="0.01" value="0.55" style="width:100%" />

      <div class="small">Samples per unknown (averaging): <span id="sampleVal">5</span></div>
      <input id="samples" type="range" min="3" max="9" step="2" value="5" style="width:100%" />

      <div class="small" style="margin-top:10px">New tickets will be saved to <code>/faceTickets/{ticketId}</code> with `descriptor` and `timestamp`.</div>

      <div id="qrs"></div>
    </div>
  </div>

  <!-- face-api global -->
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

  <!-- Firebase + logic -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getDatabase, ref, get, set, child } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";

    // ---------- FIREBASE CONFIG ----------
    const firebaseConfig = {
      apiKey: "AIzaSyDsn16p7w8b-x8pEA_WTO5F2oUk4MHwcUc",
      authDomain: "wavetravel-3c4c4.firebaseapp.com",
      databaseURL: "https://wavetravel-3c4c4-default-rtdb.firebaseio.com",
      projectId: "wavetravel-3c4c4",
      storageBucket: "wavetravel-3c4c4.firebasestorage.app",
      messagingSenderId: "298226098137",
      appId: "1:298226098137:web:720953b80e3e61c8bc43c8"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const ticketsPath = 'faceTickets';

    // ---------- UI ----------
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const msgsEl = document.getElementById('msgs');
    const datetimeEl = document.getElementById('datetime');
    const generateBtn = document.getElementById('generateBtn');
    const verifyBtn = document.getElementById('verifyBtn');
    const qrsEl = document.getElementById('qrs');

    const thresholdInput = document.getElementById('threshold');
    const samplesInput = document.getElementById('samples');
    const threshVal = document.getElementById('threshVal');
    const sampleVal = document.getElementById('sampleVal');

    let MATCH_THRESHOLD = parseFloat(thresholdInput.value);
    thresholdInput.oninput = ()=> { MATCH_THRESHOLD = parseFloat(thresholdInput.value); threshVal.innerText = MATCH_THRESHOLD.toFixed(2); };

    let SAMPLES = parseInt(samplesInput.value,10);
    samplesInput.oninput = ()=> { SAMPLES = parseInt(samplesInput.value,10); sampleVal.innerText = SAMPLES; };

    const RESIZE_SCALE = 0.25;
    const PROCESS_EVERY_N = 2;

    // ---------- State ----------
    let knownTickets = []; // [{id, encoding:Float32Array, meta}]
    let latestDetections = []; // [{box, descriptor}]
    let modelsLoaded = false;

    // ---------- Helpers ----------
    function showMsg(text, timeout=2200) {
      const div = document.createElement('div'); div.className='msg'; div.innerText = text; msgsEl.prepend(div);
      setTimeout(()=> div.remove(), timeout);
    }
    function updateDateTime(){ datetimeEl.innerText = new Date().toLocaleString(); }
    setInterval(updateDateTime,1000); updateDateTime();

    function euclidean(a,b){
      let s=0; for (let i=0;i<a.length;i++){ const d=a[i]-b[i]; s+=d*d; } return Math.sqrt(s);
    }

    // ---------- Load known tickets ----------
    async function loadKnownTickets(){
      try {
        statusEl.innerText = 'Loading tickets from Firebase...';
        const snap = await get(child(ref(db), ticketsPath));
        const data = snap.exists() ? snap.val() : {};
        const loaded = [];
        for (const [k,v] of Object.entries(data)) {
          const arr = v.encoding || v.descriptor || v.descriptorArray || null;
          if (Array.isArray(arr) && arr.length >= 128) {
            loaded.push({ id: k, encoding: new Float32Array(arr), meta: v });
          }
        }
        knownTickets = loaded;
        statusEl.innerText = `Loaded ${knownTickets.length} ticket(s)`;
      } catch (e) {
        console.error("loadKnownTickets:", e);
        statusEl.innerText = 'Failed to load tickets';
      }
    }

    // ---------- Model loading & camera ----------
    async function loadModels(){
      statusEl.innerText = 'Loading face-api models (from ./models)...';
      try {
        await Promise.all([
          faceapi.nets.tinyFaceDetector.loadFromUri('./models'),
          faceapi.nets.faceLandmark68Net.loadFromUri('./models'),
          faceapi.nets.faceRecognitionNet.loadFromUri('./models')
        ]);
        modelsLoaded = true;
        statusEl.innerText = 'Models loaded';
      } catch (e) {
        console.error("loadModels error:", e);
        statusEl.innerText = 'Model load failed - check ./models';
        throw e;
      }
    }

    async function startCamera(){
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width:1280, height:720 }});
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        statusEl.innerText = 'Camera started';
      } catch (e) {
        console.error("startCamera error:", e);
        statusEl.innerText = 'Camera access error';
      }
    }

    // ---------- Main loop (multi-face detection & draw) ----------
    let frameIdx = 0;
    async function runLoop(){
      const off = document.createElement('canvas');
      off.width = Math.max(1, Math.floor(video.videoWidth * RESIZE_SCALE));
      off.height = Math.max(1, Math.floor(video.videoHeight * RESIZE_SCALE));
      const offCtx = off.getContext('2d');

      async function step() {
        frameIdx++;
        offCtx.drawImage(video, 0, 0, off.width, off.height);

        if (frameIdx % PROCESS_EVERY_N === 0 && modelsLoaded) {
          try {
            const detections = await faceapi.detectAllFaces(off, new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.45 }))
              .withFaceLandmarks()
              .withFaceDescriptors();

            latestDetections = detections.map(d => {
              const b = d.detection.box;
              return {
                box: { x: Math.round(b.x / RESIZE_SCALE), y: Math.round(b.y / RESIZE_SCALE),
                       width: Math.round(b.width / RESIZE_SCALE), height: Math.round(b.height / RESIZE_SCALE) },
                descriptor: d.descriptor
              };
            });
          } catch (e) {
            console.error("detect error:", e);
          }
        }

        // draw overlay
        ctx.clearRect(0,0,canvas.width,canvas.height);
        for (const det of latestDetections) {
          let best = {id:null, dist: Infinity};
          for (const t of knownTickets) {
            const d = euclidean(det.descriptor, t.encoding);
            if (d < best.dist) { best.dist = d; best.id = t.id; }
          }

          // compute mirrored X so overlay matches mirrored video
          const x = det.box.x, y = det.box.y, w = det.box.width, h = det.box.height;
          const mirroredX = canvas.width - x - w;

          if (best.dist <= MATCH_THRESHOLD) {
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = Math.max(2, Math.round(Math.min(6, w*0.02)));
            ctx.strokeRect(mirroredX, y, w, h);
            // label
            ctx.fillStyle = 'rgba(0,128,0,0.85)';
            const label = best.id || 'ticket';
            const textW = Math.min(260, ctx.measureText(label).width + 12);
            ctx.fillRect(mirroredX, y + h - 26, textW, 26);
            ctx.fillStyle = '#fff'; ctx.font = '16px Arial';
            ctx.fillText(label, mirroredX + 6, y + h - 6);
          } else {
            // unknown circle
            const cx = mirroredX + Math.round(w/2), cy = y + Math.round(h/2), r = Math.round(Math.max(w,h)/2);
            ctx.strokeStyle = 'rgba(255,50,50,0.95)'; ctx.lineWidth = Math.max(2, Math.round(Math.min(6, w*0.02)));
            ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
            // label
            ctx.fillStyle = 'rgba(200,40,40,0.9)'; ctx.fillRect(mirroredX, y + h - 26, 110, 26);
            ctx.fillStyle = '#fff'; ctx.font = '14px Arial'; ctx.fillText('Unknown', mirroredX + 6, y + h - 6);
          }
        }

        requestAnimationFrame(step);
      }

      requestAnimationFrame(step);
    }

    // ---------- Helpers for sampling & averaging ----------
    // sampleAverageForBoxes: for each box, resample SAMPLES times and average descriptors
    async function sampleAverageForBoxes(boxes, samplesPerBox=5, delayMs = 200) {
      // boxes: array of {x,y,width,height} in full coords (the detection boxes)
      const accum = boxes.map(() => []);
      for (let s=0; s<samplesPerBox; s++) {
        const off = document.createElement('canvas');
        off.width = Math.max(1, Math.floor(video.videoWidth * RESIZE_SCALE));
        off.height = Math.max(1, Math.floor(video.videoHeight * RESIZE_SCALE));
        const offCtx = off.getContext('2d');
        offCtx.drawImage(video, 0, 0, off.width, off.height);
        const dets = await faceapi.detectAllFaces(off, new faceapi.TinyFaceDetectorOptions({ scoreThreshold:0.45 }))
          .withFaceLandmarks()
          .withFaceDescriptors();
        const fullDets = dets.map(d => {
          const b = d.detection.box;
          return { box: { x: Math.round(b.x / RESIZE_SCALE), y: Math.round(b.y / RESIZE_SCALE),
                          width: Math.round(b.width / RESIZE_SCALE), height: Math.round(b.height / RESIZE_SCALE) },
                   descriptor: d.descriptor };
        });

        // for each target box, choose the detection nearest to its center
        for (let i=0;i<boxes.length;i++){
          const tb = boxes[i];
          let best={det:null,score:-Infinity};
          const tcx = tb.x + tb.width/2, tcy = tb.y + tb.height/2;
          for (const fd of fullDets) {
            const cx = fd.box.x + fd.box.width/2, cy = fd.box.y + fd.box.height/2;
            const dist = Math.hypot(cx - tcx, cy - tcy);
            const score = 1/(1+dist);
            if (score > best.score) best = {det: fd, score};
          }
          if (best.det) accum[i].push(best.det.descriptor);
        }
        await new Promise(r => setTimeout(r, delayMs));
      }

      // average lists
      function avg(list) {
        if (!list || list.length===0) return null;
        const L = list[0].length;
        const out = new Float32Array(L);
        for (const a of list) for (let j=0;j<L;j++) out[j] += a[j];
        for (let j=0;j<L;j++) out[j] /= list.length;
        return out;
      }
      return accum.map(lst => avg(lst));
    }

    // ---------- ticket-id allocator (single definition) ----------
    async function allocateTicketIds(prefix, count) {
      // prefix: MMYYYY as string, e.g. "082025". returns array of count string ids.
      try {
        const snap = await get(child(ref(db), ticketsPath));
        const data = snap.exists() ? snap.val() : {};
        const existing = Object.keys(data || {}).filter(k => k.startsWith(prefix));
        const nums = existing.map(k => parseInt(k, 10)).filter(x => !isNaN(x));
        let next = nums.length ? Math.max(...nums) + 1 : parseInt(prefix + '101', 10);
        const out = [];
        for (let i=0;i<count;i++){ out.push(String(next)); next++; }
        return out;
      } catch (e) {
        console.error("allocateTicketIds error:", e);
        const base = parseInt(prefix + '101', 10);
        return Array.from({length: count}, (_,i) => String(base + i));
      }
    }

    // ---------- Generate tickets for current unknown faces ----------
    generateBtn.addEventListener('click', async () => {
      if (!modelsLoaded) { showMsg('Models still loading'); return; }
      if (!latestDetections || latestDetections.length===0) { showMsg('No faces visible'); return; }

      // collect boxes of unknown faces
      const unknownBoxes = [];
      for (const det of latestDetections) {
        let best = { dist: Infinity };
        for (const t of knownTickets) {
          const d = euclidean(det.descriptor, t.encoding);
          if (d < best.dist) best = { dist: d, id: t.id };
        }
        if (best.dist > MATCH_THRESHOLD) {
          unknownBoxes.push(det.box);
        }
      }

      if (unknownBoxes.length === 0) { showMsg('No unknown faces'); return; }

      statusEl.innerText = `Capturing ${SAMPLES} samples for ${unknownBoxes.length} unknown(s)...`;
      showMsg(`Capturing ${unknownBoxes.length} unknown(s)`);

      const averaged = await sampleAverageForBoxes(unknownBoxes, SAMPLES);
      // filter valid averaged descriptors
      const valid = averaged.map((v,i) => ({avg:v, box:unknownBoxes[i]})).filter(x => x.avg !== null);
      if (valid.length === 0) { showMsg('Capture failed'); statusEl.innerText = 'Capture failed'; return; }

      // allocate ids
      const now = new Date();
      const prefix = String(now.getMonth()+1).padStart(2,'0') + String(now.getFullYear());
      const ids = await allocateTicketIds(prefix, valid.length);

      // save to Firebase under /faceTickets/{ticketId}
      const saved = [];
      for (let i=0;i<valid.length;i++){
        const id = ids[i];
        const desc = Array.from(valid[i].avg);
        const payload = { encoding: desc, timestamp: new Date().toISOString() };
        try {
          await set(child(ref(db), `${ticketsPath}/${id}`), payload);
          saved.push(id);
        } catch (e) {
          console.error("save ticket error", e);
        }
      }

      if (saved.length) {
        showMsg(`Saved ${saved.length} ticket(s)`, 3000);
        statusEl.innerText = `Saved: ${saved.join(', ')}`;
        qrsEl.innerHTML = '';
        for (const tid of saved) {
          const div = document.createElement('div'); div.className='qr-item';
          const url = `${location.origin}/ticket.html?ticket=${encodeURIComponent(tid)}`;
          div.innerHTML = `<div style="font-weight:700">${tid}</div>
            <img alt="qr" src="https://chart.googleapis.com/chart?cht=qr&chs=150x150&chl=${encodeURIComponent(url)}" style="margin-top:8px;border-radius:6px" />`;
          qrsEl.prepend(div);
        }
        // reload known tickets to include newly saved
        await loadKnownTickets();
      } else {
        showMsg('No tickets saved (error)', 3000);
        statusEl.innerText = 'Save error';
      }
    });

    // ---------- quick verify (single-shot) ----------
    verifyBtn.addEventListener('click', async () => {
      if (!modelsLoaded) { showMsg('Models loading'); return; }
      if (!latestDetections || latestDetections.length===0) { showMsg('No faces visible'); return; }
      let found = 0;
      let info = [];
      for (const det of latestDetections) {
        let best = { id:null, dist: Infinity };
        for (const t of knownTickets) {
          const d = euclidean(det.descriptor, t.encoding);
          if (d < best.dist) best = { id: t.id, dist: d };
        }
        if (best.dist <= MATCH_THRESHOLD) { found++; info.push(`${best.id} (d=${best.dist.toFixed(3)})`); }
        else info.push(`Unknown (best ${best.id || 'none'} d=${best.dist.toFixed(3)})`);
      }
      showMsg(`Verified ${found}/${latestDetections.length}`, 3000);
      statusEl.innerText = info.join(' | ');
    });

    // ---------- init ----------
    async function init(){
      try {
        await loadModels();
        await startCamera();
        await loadKnownTickets();
        setInterval(loadKnownTickets, 30000);
        runLoop();
      } catch (e) {
        console.error("Init error:", e);
      }
    }
    init();

    // debugging
    window.__faceTickets = { loadKnownTickets, knownTickets, latestDetections };

  </script>
</body>
</html>
