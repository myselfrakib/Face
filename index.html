<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Face Ticketing â€” Generate Tickets (manual)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bg:#071022;--panel:#0b1320;--accent:#10b981;--text:#e6f7f1}
    body{margin:0;font-family:Inter,Arial;background:var(--bg);color:var(--text);display:flex;align-items:center;justify-content:center;height:100vh}
    .app{display:flex;gap:18px;width:100%;max-width:1200px;padding:20px;box-sizing:border-box}
    .camera{position:relative;width:720px}
    video{width:720px;height:540px;background:#000;border-radius:10px;object-fit:cover;transform:scaleX(-1)} /* mirrored for user */
    canvas{position:absolute;left:0;top:0;width:720px;height:540px;pointer-events:none}
    .panel{width:360px;background:var(--panel);padding:16px;border-radius:10px}
    .btn{width:100%;padding:12px;border-radius:8px;border:none;cursor:pointer;font-weight:700;margin-top:8px}
    .btn-generate{background:#10b981;color:#012}
    .btn-verify{background:#3b82f6;color:#fff}
    .status{margin-top:12px;color:#bde;font-size:14px;min-height:46px}
    .small{font-size:13px;color:#9db;margin-top:8px}
    #datetime{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.45);padding:8px 10px;border-radius:8px;z-index:20}
    #message{position:absolute;right:12px;top:12px;z-index:20;text-align:right}
    #message .msg{background:rgba(0,0,0,0.6);padding:6px 10px;border-radius:8px;color:#fff}
  </style>
</head>
<body>
  <div class="app">
    <div class="camera">
      <div id="datetime">--</div>
      <div id="message"><div class="msg">Initializing...</div></div>
      <video id="video" autoplay muted playsinline></video>
      <canvas id="overlay" width="720" height="540"></canvas>
    </div>

    <div class="panel">
      <h3 style="margin:0 0 8px 0">Face Ticket System (Online-only)</h3>

      <button id="generateBtn" class="btn btn-generate">Generate Tickets for Unknowns</button>
      <button id="verifyBtn" class="btn btn-verify">Quick Verify (scan now)</button>
      <button id="refreshBtn" class="btn" style="background:#f59e0b;color:#012">Reload Known Faces</button>

      <div class="status" id="status">Loading models...</div>

      <div class="small">Threshold: <span id="threshVal">0.55</span></div>
      <input id="threshold" type="range" min="0.40" max="0.70" step="0.01" value="0.55" style="width:100%" />

      <div class="small">Process every N frames: <span id="procVal">2</span></div>
      <input id="proc" type="range" min="1" max="4" step="1" value="2" style="width:100%" />

      <div class="small" style="margin-top:10px">When you press <b>Generate Tickets</b>, the app captures multiple samples per unknown face, averages them and saves descriptors under <code>/faceTickets/{ticketId}</code>.</div>
    </div>
  </div>

  <!-- vladmandic face-api bundle (includes tf) -->
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getDatabase, ref, get, set, child } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";

    // ---------- CONFIG ----------
    const MODEL_URL = 'https://raw.githubusercontent.com/myselfrakib/Face/main/models'; // your GitHub models folder
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyDsn16p7w8b-x8pEA_WTO5F2oUk4MHwcUc",
      authDomain: "wavetravel-3c4c4.firebaseapp.com",
      databaseURL: "https://wavetravel-3c4c4-default-rtdb.firebaseio.com",
      projectId: "wavetravel-3c4c4",
      storageBucket: "wavetravel-3c4c4.firebasestorage.app",
      messagingSenderId: "298226098137",
      appId: "1:298226098137:web:720953b80e3e61c8bc43c8"
    };
    const TICKETS_PATH = 'faceTickets';
    const RESIZE_SCALE = 0.25;

    // ---------- UI ----------
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const messageEl = document.getElementById('message');
    const datetimeEl = document.getElementById('datetime');
    const generateBtn = document.getElementById('generateBtn');
    const verifyBtn = document.getElementById('verifyBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const thresholdInput = document.getElementById('threshold');
    const procInput = document.getElementById('proc');
    const threshVal = document.getElementById('threshVal');
    const procVal = document.getElementById('procVal');

    let MATCH_THRESHOLD = parseFloat(thresholdInput.value);
    let PROCESS_EVERY_N = parseInt(procInput.value,10) || 2;
    threshVal.innerText = MATCH_THRESHOLD.toFixed(2);
    procVal.innerText = PROCESS_EVERY_N;
    thresholdInput.oninput = ()=> { MATCH_THRESHOLD = parseFloat(thresholdInput.value); threshVal.innerText = MATCH_THRESHOLD.toFixed(2); };
    procInput.oninput = ()=> { PROCESS_EVERY_N = parseInt(procInput.value,10); procVal.innerText = PROCESS_EVERY_N; };

    function setStatus(t){ statusEl.innerText = t; messageEl.innerHTML = `<div class="msg">${t}</div>`; }
    function setMessage(t, ms=2000){ messageEl.innerHTML = `<div class="msg">${t}</div>`; setTimeout(()=> messageEl.innerHTML='', ms); }
    function updateDateTime(){ datetimeEl.innerText = new Date().toLocaleString(); }
    setInterval(updateDateTime, 1000); updateDateTime();

    // ---------- state ----------
    let db;
    let knownTickets = []; // {id, encoding: Float32Array}
    let modelsLoaded = false;
    let frameIdx = 0;
    let latestDetections = [];

    // ---------- firebase init ----------
    function initFirebase(){
      const app = initializeApp(FIREBASE_CONFIG);
      db = getDatabase(app);
      setStatus("Firebase initialized");
    }

    // ---------- load models ----------
    async function loadModels(){
      setStatus("Setting TF backend and loading models...");
      try {
        if (faceapi && faceapi.tf && faceapi.tf.setBackend){
          try { await faceapi.tf.setBackend('webgl'); await faceapi.tf.ready(); }
          catch(e){ await faceapi.tf.setBackend('cpu'); await faceapi.tf.ready(); }
        }
      } catch(e){ console.warn("backend switch error", e); }
      await Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
        faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
        faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)
      ]);
      modelsLoaded = true;
      setStatus("Models loaded");
    }

    // ---------- camera ----------
    async function startCamera(){
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width:1280, height:720 } });
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        setStatus("Camera started");
      } catch(e){
        console.error(e);
        setStatus("Camera access error");
      }
    }

    // ---------- db helpers ----------
    async function loadKnownTicketsFromFirebase(){
      try {
        setStatus("Loading known tickets from Firebase...");
        const snap = await get(ref(db, TICKETS_PATH));
        const data = snap.exists() ? snap.val() : {};
        const loaded = [];
        for (const [k,v] of Object.entries(data || {})){
          const enc = v.encoding || v.descriptor || null;
          if (Array.isArray(enc) && enc.length >= 128) loaded.push({ id:k, encoding: new Float32Array(enc), meta:v });
        }
        knownTickets = loaded;
        setStatus(`Loaded ${knownTickets.length} tickets`);
      } catch(e){
        console.error("loadKnownTicketsFromFirebase", e);
        setStatus("Failed to load tickets (check console)");
      }
    }

    async function allocateTicketIdOnline(){
      const now = new Date();
      const prefix = String(now.getMonth()+1).padStart(2,'0') + String(now.getFullYear());
      try {
        const snap = await get(ref(db, TICKETS_PATH));
        const data = snap.exists() ? snap.val() : {};
        const keys = Object.keys(data || {});
        const samePrefix = keys.filter(k => k.startsWith(prefix)).map(k => parseInt(k,10)).filter(n => !isNaN(n));
        if (!samePrefix.length) return prefix + '101';
        return String(Math.max(...samePrefix) + 1);
      } catch(e){
        console.warn('allocateTicketIdOnline error', e);
        return prefix + String(Math.floor(Date.now() / 1000));
      }
    }

    async function saveTicketOnline(ticketId, encoding, meta={}){
      const payload = Object.assign({ encoding: Array.from(encoding), timestamp: new Date().toISOString() }, meta);
      await set(child(ref(db), `${TICKETS_PATH}/${ticketId}`), payload);
      knownTickets.push({ id: ticketId, encoding: new Float32Array(encoding), meta: payload });
      setStatus(`Saved ${ticketId}`);
    }

    // ---------- detection ----------
    async function detectAllSmall(){
      if (!modelsLoaded) return [];
      const off = document.createElement('canvas');
      off.width = Math.max(1, Math.floor(video.videoWidth * RESIZE_SCALE));
      off.height = Math.max(1, Math.floor(video.videoHeight * RESIZE_SCALE));
      const offCtx = off.getContext('2d');
      offCtx.drawImage(video, 0, 0, off.width, off.height);
      try {
        const detections = await faceapi.detectAllFaces(off, new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.45 }))
          .withFaceLandmarks()
          .withFaceDescriptors();
        return detections.map(d => {
          const b = d.detection.box;
          return {
            box: { x: Math.round(b.x / RESIZE_SCALE), y: Math.round(b.y / RESIZE_SCALE), width: Math.round(b.width / RESIZE_SCALE), height: Math.round(b.height / RESIZE_SCALE) },
            descriptor: d.descriptor
          };
        });
      } catch(e){
        console.warn("detectAllSmall error", e);
        return [];
      }
    }

    function euclidean(a,b){ let s=0; for(let i=0;i<a.length;i++){ const d=a[i]-b[i]; s+=d*d;} return Math.sqrt(s); }

    function findBestMatchLocal(descriptor){
      if (!knownTickets.length) return { found:false, bestId:null, distance:Infinity };
      let best = { id:null, dist: Infinity };
      for (const t of knownTickets){
        const d = euclidean(descriptor, t.encoding);
        if (d < best.dist) best = { id: t.id, dist: d };
      }
      return { found: best.dist <= MATCH_THRESHOLD, bestId: best.id, distance: best.dist };
    }

    // ---------- sampling (average descriptors) ----------
    async function sampleAverageForBoxes(boxes, samplesPerBox=5, delayMs=180){
      // boxes are in full coordinates: {x,y,width,height}
      const accum = boxes.map(()=>[]);
      for (let s=0;s<samplesPerBox;s++){
        const off = document.createElement('canvas');
        off.width = Math.max(1, Math.floor(video.videoWidth * RESIZE_SCALE));
        off.height = Math.max(1, Math.floor(video.videoHeight * RESIZE_SCALE));
        const offCtx = off.getContext('2d');
        offCtx.drawImage(video, 0, 0, off.width, off.height);
        const dets = await faceapi.detectAllFaces(off, new faceapi.TinyFaceDetectorOptions({ scoreThreshold:0.45 }))
          .withFaceLandmarks()
          .withFaceDescriptors();
        const fullDets = dets.map(d => {
          const b = d.detection.box;
          return { box: { x: Math.round(b.x / RESIZE_SCALE), y: Math.round(b.y / RESIZE_SCALE), width: Math.round(b.width / RESIZE_SCALE), height: Math.round(b.height / RESIZE_SCALE) }, descriptor: d.descriptor };
        });
        // match each requested box to nearest detection by center distance
        for (let i=0;i<boxes.length;i++){
          const tb = boxes[i];
          let best = { det:null, score:-Infinity };
          const tcx = tb.x + tb.width/2, tcy = tb.y + tb.height/2;
          for (const fd of fullDets){
            const cx = fd.box.x + fd.box.width/2, cy = fd.box.y + fd.box.height/2;
            const dist = Math.hypot(cx - tcx, cy - tcy);
            const score = 1/(1+dist);
            if (score > best.score) best = { det: fd, score };
          }
          if (best.det) accum[i].push(best.det.descriptor);
        }
        await new Promise(r=>setTimeout(r, delayMs));
      }
      // average
      function avg(list){
        if (!list || list.length===0) return null;
        const L = list[0].length;
        const out = new Float32Array(L);
        for (const a of list) for (let j=0;j<L;j++) out[j]+=a[j];
        for (let j=0;j<L;j++) out[j]/=list.length;
        return out;
      }
      return accum.map(lst => avg(lst));
    }

    // ---------- main loop (detect & draw) ----------
    async function mainLoop(){
      frameIdx++;
      if (frameIdx % PROCESS_EVERY_N === 0 && modelsLoaded){
        const dets = await detectAllSmall();
        latestDetections = dets;
      }
      drawOverlay();
      requestAnimationFrame(mainLoop);
    }

    // ---------- drawing: NOTE we DO NOT use ctx.setTransform to avoid mirrored text ----------
    function drawOverlay(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (const det of latestDetections){
        const b = det.box;
        // compute mirrored X because video is mirrored via CSS transform
        const mirroredX = canvas.width - b.x - b.width;

        const match = findBestMatchLocal(det.descriptor);
        if (match.found){
          ctx.strokeStyle = 'lime';
          ctx.lineWidth = Math.max(2, Math.round(Math.min(6, b.width*0.02)));
          ctx.strokeRect(mirroredX, b.y, b.width, b.height);

          // label background & text (text will be normal/readable)
          const label = match.bestId || 'ticket';
          ctx.fillStyle = 'rgba(0,128,0,0.85)';
          const textW = Math.min(260, ctx.measureText(label).width + 12);
          ctx.fillRect(mirroredX, b.y + b.height - 26, textW, 26);
          ctx.fillStyle = '#fff';
          ctx.font = '16px Arial';
          ctx.fillText(label, mirroredX + 6, b.y + b.height - 6);
        } else {
          // unknown: draw a circle around face (mirrored coords)
          const cx = mirroredX + Math.round(b.width/2), cy = b.y + Math.round(b.height/2), r = Math.round(Math.max(b.width,b.height)/2);
          ctx.strokeStyle = 'rgba(255,80,80,0.95)';
          ctx.lineWidth = Math.max(2, Math.round(Math.min(6, b.width*0.02)));
          ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();

          // label
          ctx.fillStyle = 'rgba(200,40,40,0.9)';
          ctx.fillRect(mirroredX, b.y + b.height - 26, 110, 26);
          ctx.fillStyle = '#fff'; ctx.font = '14px Arial';
          ctx.fillText('Unknown', mirroredX + 6, b.y + b.height - 6);
        }
      }
      updateDateTime();
    }

    // ---------- UI actions ----------
    verifyBtn.addEventListener('click', async () => {
      setStatus("Manual verify: scanning...");
      const dets = await detectAllSmall();
      if (!dets.length){ setStatus("No face detected"); return; }
      for (const d of dets){
        const m = findBestMatchLocal(d.descriptor);
        if (m.found) setMessage(`Ticket: ${m.bestId} (d=${m.distance.toFixed(3)})`, 4000);
        else setMessage('Unknown', 2000);
      }
    });

    refreshBtn.addEventListener('click', async () => {
      await loadKnownTicketsFromFirebase();
    });

    // Generate Tickets (manual) - samples each unknown face, averages, saves
    generateBtn.addEventListener('click', async () => {
      if (!modelsLoaded) { setStatus("Models loading"); return; }
      if (!latestDetections || latestDetections.length === 0) { setStatus("No faces visible"); return; }

      // collect unknown boxes
      const unknownBoxes = [];
      for (const det of latestDetections) {
        const m = findBestMatchLocal(det.descriptor);
        if (!m.found) unknownBoxes.push(det.box);
      }
      if (!unknownBoxes.length) { setStatus("No unknown faces to save"); return; }

      setStatus(`Capturing samples for ${unknownBoxes.length} unknown(s)...`);
      // average 5 samples per unknown
      const averaged = await sampleAverageForBoxes(unknownBoxes, 5, 160);
      const valid = averaged.map((v,i)=>({avg:v,box:unknownBoxes[i]})).filter(x=>x.avg!==null);
      if (!valid.length){ setStatus("Capture failed"); return; }

      // allocate IDs and save
      const now = new Date();
      const savedIds = [];
      for (let i=0;i<valid.length;i++){
        const id = await allocateTicketIdOnline();
        try {
          await saveTicketOnline(id, valid[i].avg, { note: 'manual-generated' });
          savedIds.push(id);
        } catch (e) {
          console.error("save error", e);
        }
      }

      if (savedIds.length) {
        setMessage(`Saved: ${savedIds.join(', ')}`, 4000);
        setStatus(`Saved ${savedIds.length} ticket(s)`);
      } else {
        setStatus("No tickets saved (error)");
      }
    });

    // ---------- init ----------
    async function init(){
      try {
        initFirebase();
        await loadModels();
        await startCamera();
        await loadKnownTicketsFromFirebase();
        setStatus("Ready (online-only). Use Generate Tickets to save unknown faces manually.");
        mainLoop();
        setInterval(loadKnownTicketsFromFirebase, 60_000); // refresh every 60s
      } catch(e){
        console.error("Init error:", e);
        setStatus("Initialization failed - see console");
      }
    }
    init();

    // debugging exposure
    window.__faceTickets = { knownTickets, latestDetections, loadKnownTicketsFromFirebase };

  </script>
</body>
</html>